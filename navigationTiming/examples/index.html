<!DOCTYPE html>
<html>

<head>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> 

<title>Timeline</title>

<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.6.1/jquery.min.js"></script>

<script type="text/javascript">

// Timeline class
// constructor arguments:
// - timelineElement is the DOM element where the timeline will be displayed
// - events is an array of objects that each have a time and eventName property
function Timeline(timelineElement, events) {
	this.events = events;
	this.timelineElement = timelineElement;
	// get the minimum and maximum time values
	this.minTime = Number.MAX_VALUE;
	this.maxTime = Number.MIN_VALUE;
	for (var i = 0; i != events.length; ++i) {
		var time = events[i].time;
		if (time > this.maxTime) {
			this.maxTime = time;
		}
		if (time < this.minTime) {
			this.minTime = time;
		}
	}
// 	console.log(this.minTime);
// 	console.log(this.maxTime);

	// defaults for event name display
	// could easily be refactored to make these values customisable
    this.eventBorderLeftColor = "#080"; 
    this.eventBorderLeftStyle = "solid"; 
    this.eventBorderLeftWidth = 2; 
    this.eventColor = "#666"; 
    this.eventMargin = 5;
    this.eventPadding = 5;
    this.eventWidth = 220; // hack: large enough to fit longest event name...
    this.fontFamily = "Consolas, sans-serif";

    // flag: to combine events with the same time in the same div
    this.combineEvents = true;

	// defaults for timeline
	this.numTicks = 5; // number of ticks on x-axis
	this.width = 800; 	

	$(timelineElement).css({
		"font-family": this.fontFamily,
		"padding-bottom": "10px", // above x-axis
		"width": this.width + "px"
		}); 	
 }

Timeline.prototype = {
	draw: function() {
		var i;
		// draw event divs
		for (i = 0; i != this.events.length; ++i) {
			var event = this.events[i];
			var eventDiv = $("<div />");
			eventDiv.append(event.eventName);
			// get the offset for the event div
			var left = (event.time / this.maxTime) * (this.width - 
					this.eventWidth - this.eventPadding - this.eventBorderLeftWidth);
            eventDiv.css({
//            	"border": "1px solid red",
                "border-left-color": this.eventBorderLeftColor,
                "border-left-style": this.eventBorderLeftStyle,
                "border-left-width": this.eventBorderLeftWidth + "px",
                "color": this.eventColor,
                "cursor": "pointer",
                "left": left, 
                "margin-bottom": this.eventMargin + "px",
                "padding-left": this.eventPadding + "px",
                "position": "relative",
                "width": this.eventWidth + "px"
            });
            eventDiv.attr({"title": event.time});
			$("#timeline").append(eventDiv);
		};		
		// draw timeline x-axis ticks and labels
		var xAxisDiv = $("<div />");
		xAxisDiv.css({
			"border-top": "1px solid #ccc" // the actual x-axis
		});
		$(this.timeElement).append(xAxisDiv);
		
		
	}
}; // Timeline class

	
$(document).ready(function(){

	///////// get performance.timing events
	
	// events is an array of objects, each with a time and an event name
	// -- note that there may be more than one event for each time
	var events = []; 
	
	// names of possible events that did not occur
	var nonEvents = []; 
	
	// minTime will be used to normalise event times so they start from zero
	var minTime = Number.MAX_VALUE;
	
	// get the time value for each attribute in performance.timing
	// each attribute is the name of a navigation or page load event
	// not all of which may have occurred, for example secureConnectionStart or redirectStart
	// -- performance.timing properties aren't enumerable in IE 9.0 so Object.keys() won't work
	for (eventName in performance.timing) {	
		var time = parseInt(performance.timing[eventName]); 
		// events that did not occur have zero time
		if (time === 0) {  
			nonEvents.push(eventName);
		} else {
			events.push({"eventName": eventName, "time": time});
			if (time < minTime) { 
				minTime = time;
			}
		}
	}
		
	// normalise times so they start from zero
	for (var i = 0; i != events.length; ++i) {
		events[i].time -= minTime;
	}
	
	// sort events by time, since object key enumeration does not guarantee this
	// -- and if events have the same time, order them so the event names are displayed  
	// in a sensible order, e.g. unloadEventStart before unloadEventEnd
	var orderedEventNames = ["navigationStart", "unloadEventStart", "unloadEventEnd", "redirectStart", "redirectEnd", "fetchStart", "domainLookupStart", "domainLookupEnd", "connectStart", "connectEnd", "secureConnectionStart", "requestStart", "responseStart", "responseEnd", "domLoading", "domInteractive", "domContentLoadedEventStart", "domContentLoadedEventEnd", "domComplete", "loadEventStart", "loadEventEnd"]	
	events.sort(function(a, b){
		// if times are different, sort by time
		if (a.time !== b.time) {
			return a.time - b.time;
		// if times are the same, sort by position in orderedEventNames
		} else {
			console.log(orderedEventNames.indexOf(a.eventName) + ", " + orderedEventNames.indexOf(b.eventName));
			// indexOf is available in IE9 and Chrome
 			return orderedEventNames.indexOf(a.eventName) - orderedEventNames.indexOf(b.eventName);
		}
	});


	// draw timeline
	var timelineElement = document.querySelector("#timeline");	
	var timelineObject = new Timeline(timelineElement, events);
	timelineObject.draw();

	// draw basic timeline x-axis ticks and labels
	var xAxisDiv = $("<div />");
		xAxisDiv.css({
		"border-top": "2px solid #060", // the actual x-axis
		"height": "40px",
		"margin": "10px 0 20px 0",
		"position": "relative"
	});	
	
	// add ticks to the x-axis: for zero and for the maximum time, timelineObject.maxTime
	var tickDivWidth = 100;
	var tickDivCss = {
		"color": "#060",
		"position": "absolute", 
		"text-align": "center",
		"top": "-4px",
		"width": tickDivWidth + "px"
		};
	// this is hacky, but it works
	var zeroTickDiv = $("<div>|<br />0</div>").css(tickDivCss).css({"left": -tickDivWidth / 2}); // 50 = half width
	// get the css left value for the max tick 
	var maxTickDivLeft = timelineObject.width - timelineObject.eventWidth - 
		timelineObject.eventPadding - timelineObject.eventBorderLeftWidth - (tickDivWidth / 2); 
	var maxTickDiv = $("<div>|<br />" + timelineObject.maxTime + "ms</div>").css(tickDivCss).
		css({"left": maxTickDivLeft});
	xAxisDiv.append(zeroTickDiv).append(maxTickDiv);
	
	$(timelineElement).append(xAxisDiv);
	
	$(timelineElement).append("<div id='nonEvents'>The following events did not occur:<br/>- " + 
		nonEvents.join("<br />- ") + "</div>");


});

</script>

</head>

<body>

<div id="timeline" />

</body>



</html>
